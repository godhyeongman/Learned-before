// 모듈은 단독으로 컴파일 가능하며 재사용 할 수 있음 (소프트웨어 공학적인 모듈)
// 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독림됨을 의미하는 것으로 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어짐
// 모듈은 단독으로 컴파일 가능하며 재사용 할 수 있음
// 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독림됨을 의미하는 것으로 모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제함으로써 이루어짐
// 이런 느낌입니다!
// 그냥
// 하나의 기능을 수행하는 독립적이고 재사용 가능한 개체라고 생각하지면 좋을거 같아요
// 그래서 저희가
// 개발을 할때
// 도트가 말씀하신거 같은
// 다른 파일에서 import 받아오는것도
// 모듈 단위로 받아오는거져
// 하나의 작업을 하는 뭔가를 가져와서
// 사용하는거니까?
// 이해가 가셨을까요
// 모듈의 단위는
// 완전 작게는 하나의 함수가 될 수도 있고
// 아니면 그런 함수들을 묶어놓은 파일 하나가 될 수도 있고
/*------------- 자료 결합도  -------------*/
//데이터 타입에 주의

function calculateMoney(money) {
  return money - discountMoney(money);
}

function discountMoney(money) {
  return money * 0.2;
}

/*------------- 스탬프 결합도  -------------*/

//모듈 간의 인터페이스로 배열이나 오브젝트 같은 자료 구조가 전달 되는 경우
//자료구조 형태가 변경되면 그것을 참조하는 모듈에 영향을 줌
//모듈간에 서로 딱 필요한 데이터만 주고 받을 수 없이 불필요한 부분도 다 받아야 하고 그 타입에 대해 알고 있어야 함.

function foo() {
  const data = new FooClass();
  sendObject(data);
}

function sendObject(data) {
  // data 를 쓰는 법을 알아야함
}

/*------------- 스탬프 결합도  -------------*/

//다른 모듈의 논리적인 흐름을 제어할 수 있는 요소를 전달하는 경우
// 정보 은닉을 크게 위배하여 다른 모듈의 내부에 관여해서 관계가 복잡해지고 그로인한 유지보수가 어려워짐

function setInputData() {
  setData("input", "text");
  change(true);
}

function setData(type, data) {
  switch (type) {
    case "input":
      this.data.input = text;
      break;
    // case 'etc' : ...
  }
}

function change(isChanged) {
  if (isChanged) {
    run();
  } else {
    stop();
  }
}
